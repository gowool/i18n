package i18n

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io/fs"
	"maps"
	"os"
	"path/filepath"
	"regexp"
	"slices"
	"strings"
)

const (
	goFileHeader = `// Code generated by i18n-extract. DO NOT EDIT.
package %s

import (
	"golang.org/x/text/language"
	"golang.org/x/text/message"
)

//nolint:unused
func _i18n_extract() {
	p := message.NewPrinter(language.English)
`
	goFileMessage = "\t_ = p.Sprintf(%s)\n"
	goFileFooter  = `}
`
)

var (
	reI18n          = regexp.MustCompile(`{{\s*(i18n|T|t)\s+`)
	reAllStringArgs = regexp.MustCompile(`"((?:[^"\\]|\\.)*)"`)
	unescape        = strings.NewReplacer(`\"`, `"`, `\\`, `\`, `\n`, "\n", `\t`, "\t")
)

// Message holds extracted message metadata.
type Message struct {
	ID        string   `json:"id"`                  // original message (singular or formatted)
	Positions []string `json:"positions,omitempty"` // file:line:col where found
}

// OutputJSON is the top-level JSON structure we write (simple map by ID).
type OutputJSON struct {
	Messages []*Message `json:"messages"`
}

type Extractor struct {
	dir    string
	out    string
	pkg    string
	goFile string
	exts   map[string]struct{}
}

func NewExtractor(dir, out, pkg, goFile string, exts ...string) *Extractor {
	em := make(map[string]struct{}, len(exts))
	for _, e := range exts {
		em[e] = struct{}{}
	}

	return &Extractor{
		dir:    dir,
		out:    out,
		pkg:    pkg,
		goFile: goFile,
		exts:   em,
	}
}

func (e *Extractor) Extract() error {
	messages, err := e.extract()
	if err != nil {
		return fmt.Errorf("extract error: %w", err)
	}

	return errors.Join(
		e.saveMessages(messages),
		e.saveGoFile(messages),
	)
}

func (e *Extractor) extract() ([]*Message, error) {
	all := make(map[string]*Message)

	err := filepath.WalkDir(e.dir, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			return nil
		}

		if !e.isTemplate(path) {
			return nil
		}

		b, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		rel, _ := filepath.Rel(e.dir, path)
		extractFromContent(all, b, rel)

		return nil
	})
	if err != nil {
		return nil, fmt.Errorf("walk error: %w", err)
	}

	messages := slices.Collect(maps.Values(all))

	slices.SortFunc(messages, func(a, b *Message) int {
		return strings.Compare(a.ID, b.ID)
	})

	return messages, nil
}

func (e *Extractor) saveMessages(messages []*Message) error {
	if e.out == "" {
		return nil
	}

	outJSON := OutputJSON{Messages: messages}

	raw, err := json.MarshalIndent(outJSON, "", "  ")
	if err != nil {
		return fmt.Errorf("json marshal: %w", err)
	}

	if err := os.WriteFile(e.out, raw, 0644); err != nil {
		return fmt.Errorf("write out: %w", err)
	}

	fmt.Printf("Wrote %d messages → %s\n", len(messages), e.out)

	return nil
}

func (e *Extractor) saveGoFile(messages []*Message) error {
	goCode, err := e.buildSyntheticGo(messages)
	if err != nil {
		return fmt.Errorf("build go file: %w", err)
	}

	if err := os.WriteFile(e.goFile, goCode, 0644); err != nil {
		return fmt.Errorf("write go file: %w", err)
	}

	fmt.Printf("Wrote synthetic Go file → %s (run 'gotext extract/update' on it)\n", e.goFile)

	return nil
}

func (e *Extractor) buildSyntheticGo(messages []*Message) ([]byte, error) {
	var buf bytes.Buffer

	if _, err := fmt.Fprintf(&buf, goFileHeader, sanitizePkgName(e.pkg)); err != nil {
		return nil, err
	}

	for _, msg := range messages {
		if _, err := fmt.Fprintf(&buf, goFileMessage, strconvQuote(msg.ID)); err != nil {
			return nil, err
		}
	}

	if _, err := buf.WriteString(goFileFooter); err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func (e *Extractor) isTemplate(path string) bool {
	ext := strings.ToLower(filepath.Ext(path))
	_, ok := e.exts[ext]
	return ok
}

func extractFromContent(ret map[string]*Message, content []byte, relPath string) {
	for _, id := range reI18n.FindAllIndex(content, -1) {
		start := id[1]
		end := bytes.Index(content[start:], []byte("}}"))
		if end < 0 {
			continue
		}

		segment := string(content[start : start+end])
		// find all string literal args in the segment
		strArgs := reAllStringArgs.FindAllStringSubmatch(segment, -1)
		if len(strArgs) == 0 {
			continue
		}

		str := unescape.Replace(strArgs[0][1])
		position := positionFor(content, start+1, relPath)

		if existing, ok := ret[str]; ok {
			// append position
			existing.Positions = append(existing.Positions, position)
		} else {
			ret[str] = &Message{ID: str, Positions: []string{position}}
		}
	}
}

func positionFor(content []byte, pos int, relPath string) string {
	// compute line/col from pos (0-based index)
	if pos <= 0 {
		return fmt.Sprintf("%s:?:?", relPath)
	}
	lines := bytes.Count(content[:pos], []byte("\n")) + 1
	// compute col by taking last newline index
	lastNewline := bytes.LastIndex(content[:pos], []byte("\n"))
	col := pos - lastNewline
	return fmt.Sprintf("%s:%d:%d", relPath, lines, col)
}

func strconvQuote(s string) string {
	var b strings.Builder
	b.WriteByte('"')
	for _, ch := range s {
		switch ch {
		case '\\':
			b.WriteString(`\\`)
		case '"':
			b.WriteString(`\"`)
		case '\n':
			b.WriteString(`\n`)
		case '\t':
			b.WriteString(`\t`)
		default:
			b.WriteRune(ch)
		}
	}
	b.WriteByte('"')
	return b.String()
}

func sanitizePkgName(n string) string {
	if n == "" {
		return "main"
	}
	// keep only letters, digits, underscore, ensure starts with letter
	var b strings.Builder
	for i, r := range n {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r == '_' || (i > 0 && r >= '0' && r <= '9') {
			b.WriteRune(r)
		}
	}
	out := b.String()
	if out == "" {
		return "main"
	}
	return out
}
